{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 156, "column": 0}, "map": {"version":3,"sources":["file:///Users/Admin/Desktop/project/dunkin-feedback/src/lib/auth.ts"],"sourcesContent":["import { NextAuthOptions, Session, DefaultSession, User } from 'next-auth';\nimport CredentialsProvider from 'next-auth/providers/credentials';\nimport { PrismaClient, User as PrismaUser } from '@prisma/client';\nimport bcrypt from 'bcrypt';\nimport { JWT } from 'next-auth/jwt';\nimport type { NextApiRequest, NextApiResponse } from 'next';\n\nconst prisma = new PrismaClient();\n\n// Debug mode is determined by NODE_ENV\n\n// Ensure required environment variables are set\nif (!process.env.NEXTAUTH_URL) {\n  process.env.NEXTAUTH_URL = 'http://localhost:3000';\n}\n\nif (!process.env.NEXTAUTH_SECRET) {\n  console.warn('NEXTAUTH_SECRET is not set. Using a fallback for development.');\n  process.env.NEXTAUTH_SECRET = 'your-secret-key';\n}\n\n// Cookie settings\nconst useSecureCookies = process.env.NEXTAUTH_URL.startsWith('https://');\nconst cookiePrefix = useSecureCookies ? '__Secure-' : '';\nconst cookieDomain = process.env.NODE_ENV === 'production' ? '.yourdomain.com' : undefined;\n\n// Extend the default session types\ndeclare module 'next-auth' {\n  interface Session extends DefaultSession {\n    user: {\n      id: string;\n      name?: string | null;\n      email?: string | null;\n      image?: string | null;\n      role: string;\n    } & DefaultSession['user'];\n  }\n  \n  // Extend the built-in user type to include our custom fields\n  interface User {\n    id: string;\n    name?: string | null;\n    email?: string | null;\n    password?: string | null;\n    hashedPassword?: string | null;\n    role: string;\n    image?: string | null;\n  }\n}\n\n// Extend the Prisma User model to include our custom fields\ndeclare global {\n  namespace Prisma {\n    interface User {\n      hashedPassword?: string | null;\n    }\n  }\n}\n\ndeclare module 'next-auth/jwt' {\n  interface JWT {\n    id: string;\n    role: string;\n    email?: string | null;\n    name?: string | null;\n  }\n}\n\nexport const authOptions: NextAuthOptions = {\n  providers: [\n    CredentialsProvider({\n      name: 'Credentials',\n      credentials: {\n        email: { label: 'Email', type: 'email' },\n        password: { label: 'Password', type: 'password' }\n      },\n      async authorize(credentials) {\n        try {\n          if (!credentials?.email || !credentials?.password) {\n            throw new Error('Please enter email and password');\n          }\n\n          console.log('🔍 Looking up user:', credentials.email);\n          const user = await prisma.user.findUnique({\n            where: { email: credentials.email.toLowerCase() }\n          });\n\n          if (!user) {\n            console.log('❌ User not found:', credentials.email);\n            throw new Error('Invalid email or password');\n          }\n\n          // For backward compatibility, check both password and hashedPassword\n          let passwordValid = false;\n          \n          // Handle the case where hashedPassword might be defined\n          const userWithHashed = user as PrismaUser & { hashedPassword?: string };\n          \n          if (userWithHashed.hashedPassword) {\n            // Use the new hashed password\n            console.log('🔑 Verifying hashed password for user:', user.email);\n            const isMatch = await bcrypt.compare(credentials.password, userWithHashed.hashedPassword);\n            passwordValid = isMatch;\n          } else if (user.password) {\n            // Fallback to plain text password (for development only)\n            console.warn('⚠️ Using plain text password for user:', user.email);\n            passwordValid = credentials.password === user.password;\n            \n            // If login is successful, hash the password for next time\n            if (passwordValid) {\n              console.log('🔄 Hashing password for user:', user.email);\n              const hashedPassword = await bcrypt.hash(credentials.password, 10);\n              \n              // Use raw SQL to update the hashed password\n              await prisma.$executeRaw`\n                UPDATE \"User\" \n                SET \"hashedPassword\" = ${hashedPassword}, \"password\" = '' \n                WHERE id = ${user.id}\n              `;\n            }\n          }\n          \n          if (!passwordValid) {\n            console.log('❌ Invalid password for user:', user.email);\n            throw new Error('Invalid email or password');\n          }\n\n          console.log('✅ Login successful for user:', user.email);\n          return {\n            id: user.id,\n            email: user.email,\n            name: user.name,\n            role: user.role,\n            image: null\n          };\n        } catch (error) {\n          console.error('🔴 Authorization error:', error);\n          throw error;\n        }\n      },\n    })\n  ],\n  callbacks: {\n    async jwt({ token, user, trigger, session }) {\n      // Initial sign in\n      if (user) {\n        console.log('🔄 JWT callback - user signed in:', user.email);\n        token.id = user.id;\n        token.role = (user as any).role;\n        token.name = user.name;\n        token.email = user.email;\n      }\n      // Update token with new data\n      if (trigger === 'update' && session) {\n        console.log('🔄 JWT callback - updating session');\n        return { ...token, ...session };\n      }\n      return token;\n    },\n    async session({ session, token }) {\n      if (token) {\n        console.log('🔄 Session callback - token data:', {\n          id: token.id,\n          email: token.email,\n          role: token.role,\n          name: token.name\n        });\n        \n        // Add user id and role to the session\n        if (session.user) {\n          session.user = {\n            ...session.user,\n            id: (token.id || '') as string,\n            role: (token.role || 'USER') as string,\n            name: (token.name || null) as string | null,\n            email: (token.email || null) as string | null\n          };\n        }\n      }\n      return session;\n    }\n  },\n  pages: {\n    signIn: '/login',\n    error: '/login?error=AuthenticationFailed',\n    signOut: '/login?signout=true',\n  },\n  session: {\n    strategy: 'jwt',\n    maxAge: 30 * 24 * 60 * 60, // 30 days\n    updateAge: 24 * 60 * 60, // 24 hours\n  },\n  secret: process.env.NEXTAUTH_SECRET || 'your-secret-key',\n  debug: process.env.NODE_ENV === 'development',\n  events: {\n    async signIn(message) {\n      console.log('✅ User signed in:', message.user?.email);\n    },\n    async signOut() {\n      console.log('👋 User signed out');\n    },\n    async session(message) {\n      console.log('🔁 Session active for:', message.session.user?.email);\n    }\n  }\n};\n\n// Helper function to get the current session on the server\nexport async function getServerSession() {\n  const { getServerSession } = await import('next-auth/next');\n  return getServerSession(authOptions);\n}\n\nexport { getToken } from 'next-auth/jwt';\n\n// Type for API route handlers with auth\ntype ApiHandler = (\n  req: NextApiRequest,\n  res: NextApiResponse,\n  session: Session\n) => Promise<void> | void;\n\n// Helper function to protect API routes\nexport function withAuth(handler: ApiHandler) {\n  return async (req: NextApiRequest, res: NextApiResponse) => {\n    const session = await getServerSession();\n    if (!session) {\n      res.status(401).json({ error: 'Unauthorized' });\n      return;\n    }\n    return handler(req, res, session);\n  };\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 356, "column": 0}, "map": {"version":3,"sources":["file:///Users/Admin/Desktop/project/dunkin-feedback/src/app/api/auth/%5B...nextauth%5D/route.ts"],"sourcesContent":["import NextAuth from 'next-auth';\nimport { authOptions } from '@/lib/auth';\n\nconst handler = NextAuth(authOptions);\n\nexport { handler as GET, handler as POST };\n"],"names":[],"mappings":";;;;AAAA;AACA;AAAA;;;AAEA,MAAM,UAAU,CAAA,GAAA,uIAAA,CAAA,UAAQ,AAAD,EAAE,oIAAA,CAAA,cAAW","debugId":null}}]
}