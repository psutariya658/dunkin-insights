{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 156, "column": 0}, "map": {"version":3,"sources":["file:///Users/Admin/Desktop/project/dunkin-feedback/src/lib/auth.ts"],"sourcesContent":["import { PrismaAdapter } from '@next-auth/prisma-adapter';\nimport { AuthOptions } from 'next-auth';\nimport CredentialsProvider from 'next-auth/providers/credentials';\nimport { PrismaClient } from '@prisma/client';\nimport bcrypt from 'bcrypt';\n\nconst prisma = new PrismaClient();\n\nexport const authOptions: AuthOptions = {\n  adapter: PrismaAdapter(prisma),\n  providers: [\n    CredentialsProvider({\n      name: 'credentials',\n      credentials: {\n        email: { label: 'Email', type: 'text' },\n        password: { label: 'Password', type: 'password' },\n      },\n      async authorize(credentials) {\n        if (!credentials?.email || !credentials?.password) {\n          throw new Error('Please enter email and password');\n        }\n\n        const user = await prisma.user.findUnique({\n          where: { email: credentials.email.toLowerCase() },\n        });\n\n        if (!user || !user.hashedPassword) {\n          throw new Error('No user found');\n        }\n\n        const passwordMatch = await bcrypt.compare(\n          credentials.password,\n          user.hashedPassword\n        );\n\n        if (!passwordMatch) {\n          throw new Error('Incorrect password');\n        }\n        \n        // Only allow admins to log in\n        if (user.role !== 'ADMIN') {\n            throw new Error('Access Denied: You are not an admin.');\n        }\n\n        return user;\n      },\n    }),\n  ],\n  session: {\n    strategy: 'jwt',\n  },\n  callbacks: {\n    async jwt({ token, user }) {\n      if (user) {\n        token.id = user.id;\n        token.role = user.role;\n      }\n      return token;\n    },\n    async session({ session, token }) {\n      if (session.user) {\n        session.user.id = token.id as string;\n        session.user.role = token.role as string;\n      }\n      return session;\n    },\n  },\n  secret: process.env.NEXTAUTH_SECRET,\n  pages: {\n    signIn: '/login',\n  },\n  debug: process.env.NODE_ENV === 'development',\n}; "],"names":[],"mappings":";;;AAAA;AAEA;AACA;AACA;;;;;AAEA,MAAM,SAAS,IAAI,6HAAA,CAAA,eAAY;AAExB,MAAM,cAA2B;IACtC,SAAS,CAAA,GAAA,sKAAA,CAAA,gBAAa,AAAD,EAAE;IACvB,WAAW;QACT,CAAA,GAAA,0JAAA,CAAA,UAAmB,AAAD,EAAE;YAClB,MAAM;YACN,aAAa;gBACX,OAAO;oBAAE,OAAO;oBAAS,MAAM;gBAAO;gBACtC,UAAU;oBAAE,OAAO;oBAAY,MAAM;gBAAW;YAClD;YACA,MAAM,WAAU,WAAW;gBACzB,IAAI,CAAC,aAAa,SAAS,CAAC,aAAa,UAAU;oBACjD,MAAM,IAAI,MAAM;gBAClB;gBAEA,MAAM,OAAO,MAAM,OAAO,IAAI,CAAC,UAAU,CAAC;oBACxC,OAAO;wBAAE,OAAO,YAAY,KAAK,CAAC,WAAW;oBAAG;gBAClD;gBAEA,IAAI,CAAC,QAAQ,CAAC,KAAK,cAAc,EAAE;oBACjC,MAAM,IAAI,MAAM;gBAClB;gBAEA,MAAM,gBAAgB,MAAM,qGAAA,CAAA,UAAM,CAAC,OAAO,CACxC,YAAY,QAAQ,EACpB,KAAK,cAAc;gBAGrB,IAAI,CAAC,eAAe;oBAClB,MAAM,IAAI,MAAM;gBAClB;gBAEA,8BAA8B;gBAC9B,IAAI,KAAK,IAAI,KAAK,SAAS;oBACvB,MAAM,IAAI,MAAM;gBACpB;gBAEA,OAAO;YACT;QACF;KACD;IACD,SAAS;QACP,UAAU;IACZ;IACA,WAAW;QACT,MAAM,KAAI,EAAE,KAAK,EAAE,IAAI,EAAE;YACvB,IAAI,MAAM;gBACR,MAAM,EAAE,GAAG,KAAK,EAAE;gBAClB,MAAM,IAAI,GAAG,KAAK,IAAI;YACxB;YACA,OAAO;QACT;QACA,MAAM,SAAQ,EAAE,OAAO,EAAE,KAAK,EAAE;YAC9B,IAAI,QAAQ,IAAI,EAAE;gBAChB,QAAQ,IAAI,CAAC,EAAE,GAAG,MAAM,EAAE;gBAC1B,QAAQ,IAAI,CAAC,IAAI,GAAG,MAAM,IAAI;YAChC;YACA,OAAO;QACT;IACF;IACA,QAAQ,QAAQ,GAAG,CAAC,eAAe;IACnC,OAAO;QACL,QAAQ;IACV;IACA,OAAO,oDAAyB;AAClC","debugId":null}},
    {"offset": {"line": 238, "column": 0}, "map": {"version":3,"sources":["file:///Users/Admin/Desktop/project/dunkin-feedback/src/app/api/auth/%5B...nextauth%5D/route.ts"],"sourcesContent":["import NextAuth from 'next-auth';\nimport { authOptions } from '@/lib/auth';\n\nconst handler = NextAuth(authOptions);\n\nexport { handler as GET, handler as POST }; "],"names":[],"mappings":";;;;AAAA;AACA;;;AAEA,MAAM,UAAU,CAAA,GAAA,uIAAA,CAAA,UAAQ,AAAD,EAAE,oHAAA,CAAA,cAAW","debugId":null}}]
}